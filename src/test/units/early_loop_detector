#!/bin/sh
# unit test for the code of early loop detector (2014-01-27)
# Author: Dmitry Yu Okunev <dyokunev@ut.mephi.ru> 0x8E30679C

TMPDIR=tmp-"$(basename "$0")"

cleanup() {
	rm -rf "${TMPDIR}"
}

run_test() {
	cat > "${TMPDIR}"/rc_deptree_solve_loop.c <<EOF

#include "../../librc/librc-depend.c"

int main() {
	service_id_t **una_matrix[UNAM_MAX], **una_matrix_result[UNAM_MAX];
	service_id_t service_id;
	unam_type_t unam_type, type;
	int useneedafter_count = 9;
	int loopsolver_counter, loopfound, errfound;
	char *service_id2str[] = {
		[1] = "hwclock",
		[2] = "mountall",
		[3] = "mountall-bootclean",
		[4] = "checkroot",
	};
	char *deptype_id2str[] = {
		[UNAM_USE]	= "use",
		[UNAM_AFTER]	= "after",
		[UNAM_NEED]	= "need",
	};

	unam_type = 0;
	while (unam_type < UNAM_MAX) {
		una_matrix[unam_type]        = xcalloc((useneedafter_count+1), sizeof(*una_matrix));
		una_matrix_result[unam_type] = xcalloc((useneedafter_count+1), sizeof(*una_matrix));
		service_id = 0;
		while(service_id < (useneedafter_count+1)) {
			una_matrix       [unam_type][service_id] = xcalloc((useneedafter_count+1), sizeof(**una_matrix));
			una_matrix_result[unam_type][service_id] = xcalloc((useneedafter_count+1), sizeof(**una_matrix));
			service_id++;
		}
		unam_type++;
	}

	/* hwclock */
	una_matrix[UNAM_USE  ][1][0] = 2;	/* the count */
	una_matrix[UNAM_USE  ][1][1] = 2;	/* "mountall" */
	una_matrix[UNAM_USE  ][1][2] = 3;	/* "mountall-bootclean" */

	/* mountall */
	una_matrix[UNAM_NEED ][2][0] = 1;	/* the count */
	una_matrix[UNAM_NEED ][2][1] = 4;	/* "checkroot" */

	/* mountall-bootclean */
	una_matrix[UNAM_NEED ][3][0] = 1;	/* the count */
	una_matrix[UNAM_NEED ][3][1] = 2;	/* "mountall" */

	/* checkroot */
	una_matrix[UNAM_AFTER][4][0] = 1;	/* the count */
	una_matrix[UNAM_AFTER][4][1] = 1;	/* "hwclock" */

	una_matrix[0][0][0] = 5; /* number of services+1 */

	/* expected result */

	una_matrix_result[UNAM_USE  ][1][0] = 0;

	una_matrix_result[UNAM_NEED ][2][0] = 1;
	una_matrix_result[UNAM_NEED ][2][1] = 4;

	una_matrix_result[UNAM_NEED ][3][0] = 1;
	una_matrix_result[UNAM_NEED ][3][1] = 2;

	una_matrix_result[UNAM_AFTER][4][0] = 1;
	una_matrix_result[UNAM_AFTER][4][1] = 1;

	/* solving */

	loopsolver_counter = 0;
	do {
		loopfound = 0;

		rc_deptree_unam_prepare_mixed(una_matrix, useneedafter_count);

		service_id=1;
		while ((service_id < (useneedafter_count+1)) && !loopfound) {
			int dep_num, dep_count;

			dep_num = 0;
			dep_count = una_matrix[UNAM_MIXED_EXPANDED][service_id][0];
			while (dep_num < dep_count) {
				dep_num++;
				if (una_matrix[UNAM_MIXED_EXPANDED][service_id][dep_num] == service_id) {
					loopfound = rc_deptree_solve_loop(una_matrix, service_id, NULL, dep_num);
					loopsolver_counter++;
					break;
				}
			}

			service_id++;
		}
	} while (loopfound == LOOP_SOLVABLE && loopsolver_counter < LOOPSOLVER_LIMIT);
	/* don't free memory, it's just a unittest */

	/* checking the result */


	errfound = 0;
	type = 0;
	while (type <= UNAM_AFTER) {
		service_id = 1;
		while (service_id < (useneedafter_count+1)) {
			int dep_count, dep_num;

			dep_num   = 0;
			dep_count = una_matrix_result[type][service_id][0];

			while (dep_num++ < dep_count) {
				int dep_count2, dep_num2, found;
				found = 0;

				dep_num2   = 0;
				dep_count2 = una_matrix[type][service_id][0];

				while (dep_num2++ < dep_count2)
					if (
						una_matrix_result[type][service_id][dep_num]
						  ==
						una_matrix       [type][service_id][dep_num2]
					) {
						found = 1;
						break;
					}

				if (!found) {
					printf("unit-test: early loop detector: error: There's no \"%s\"\tdependency: %s -> %s\n",
							deptype_id2str[type],
							service_id2str[service_id],
							service_id2str[una_matrix_result[type][service_id][dep_num]]
						);
					errfound = 1;
				}
			}

			dep_num   = 0;
			dep_count = una_matrix[type][service_id][0];

			while (dep_num++ < dep_count) {
				int dep_count2, dep_num2, found;
				found = 0;

				dep_num2   = 0;
				dep_count2 = una_matrix_result[type][service_id][0];

				while (dep_num2++ < dep_count2)
					if (
						una_matrix_result[type][service_id][dep_num2]
						  ==
						una_matrix       [type][service_id][dep_num]
					) {
						found = 1;
						break;
					}

				if (!found) {
					printf("unit-test: early loop detector: error: There's extra \"%s\"\tdependency found: %s -> %s\n",
							deptype_id2str[type],
							service_id2str[service_id],
							service_id2str[una_matrix[type][service_id][dep_num]]
						);
					errfound = 1;
				}
			}

			service_id++;
		}
		type++;
	}

	return errfound != 0;
}

EOF
	gcc -ggdb3 -O0 -I../includes/ "${TMPDIR}"/rc_deptree_solve_loop.c ../libeinfo/libeinfo.o ../librc/librc.o ../librc/librc-stringlist.o ../librc/librc-misc.o  -o "${TMPDIR}"/rc_deptree_solve_loop
	./"${TMPDIR}"/rc_deptree_solve_loop
}


cleanup
mkdir "${TMPDIR}"
trap cleanup INT TERM EXIT

run_test
exit $?
